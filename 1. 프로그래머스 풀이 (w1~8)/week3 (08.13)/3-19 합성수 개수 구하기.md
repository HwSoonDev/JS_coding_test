```js
function isPrime(n) {
    if (n < 2) return false; // 0과 1은 소수가 아님
    if (n === 2) return true; // 2는 소수
    if (n % 2 === 0) return false; // 짝수는 소수 아님 (2 제외)

    const sqrt = Math.floor(Math.sqrt(n));
    for (let i = 3; i <= sqrt; i += 2) {
        if (n % i === 0) return false;
    }
    return true;
}
```
소수인지 판별하는 유명한 함수 패턴

이걸 사용해도 되지만,
저는 소수를 구하면서 동시에 합성수를 걸러내는 식으로 짜보았습니다.

```js
function solution(n) {
   
    let cnt = 0;
    const primes = [2, 3];
    
    for(let i=4; i<=n; i++){
        let isComposite = false;
        for(let prime of primes){
		    //sqrt 이하 소수에 대해서만 실시
            if(prime > Math.sqrt(i)){break;}
            
            if(i%prime==0){
                cnt++;
                isComposite = true;
                break;
            }
        }
        if(isComposite){continue;}
        primes.push(i);
    }
    
    return cnt;
}
```

4 미만은  합성수가 없으므로 for문을 돌지 않습니다.

2, 3은 소수입니다.
이후 숫자는 앞서 발견한 소수의 배수인지 판별합니다.
- 어떤 소수의 배수도 아니면 소수에 추가합니다.
- 소수의 배수라면 합성수 카운트를 올립니다.

소수를 구하면서, 동시에 합성수를 구해서 시간 복잡도를 줄여 보았습니다.

유명한 함수 패턴은 3 이상, sqrt이하 **홀수**의 배수인지 판별하지만,
이 방법은 sqrt 이하 **소수**의 배수인지 판별합니다.
