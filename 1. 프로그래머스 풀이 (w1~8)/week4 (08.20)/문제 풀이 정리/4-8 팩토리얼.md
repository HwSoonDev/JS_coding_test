내 풀이
```js
function solution(n) {
    let i = 1;
    let factorial = 1;
    if(n===0){return 0}
    if(n===1){return 1}
    while(factorial<= n){
        i++;
        factorial *= i;
    }
    return i-1;
}
```
보통 조건으로 빠져나가고 싶으면 while문을 쓴다고 생각합니다.
(이게 최선일까 싶지만요)

다른 풀이
```js
function solution(n) {
    for(let i = 1, v = 1; true; v *= ++i) if(v > n) return --i;
}
```

크으으 for문에 대해 완벽히 이해한 사람의 풀이를 봐서 좋았습니다.
예술에 가깝습니다.

나는 그저 for문으로도 충분하기에 for문을 택했을 뿐,
반복문을 빠져 나가는 것은 내가 결정한다.
라고 말하는 듯한 시크한 스타일의 코드.

분명 for문인데 증감자에서 멋대로 하고 싶은 계산을 하고 있고.
인덱스를 도는 것과는 전혀 상관 없는 모양새를 하고 있지만,
(실무에서는 혼날 거 같은)

저의 **뒤틀린 코딩 철학**을 자극할 것만 같은 너무 멋진 코드였습니다.

## for 기본 구조

```
for (초기화; 조건; 증감) {   // 반복 실행할 코드 }
```

| 부분      | 실행 시점         | 역할                                                                                    |
| ------- | ------------- | ------------------------------------------------------------------------------------- |
| **초기화** | 반복문 진입 시 딱 1번 | 반복 제어 변수 선언 및 초기값 설정                                                                  |
| **조건**  | 반복 시작 전마다     | 반복을 계속할지 결정 (`true` → 반복, `false` → 종료)                                               |
| **증감**  | 블록 실행 후마다     | 보통 반복 제어 변수 증가/감소 등 조작<br><br>하지만 어떤 표현식이든 들어갈 수 있다.<br>블록 마지막에 실행하고 싶은 코드를 넣을 수도 있다. |

1) 인덱스로 돌 때
2) 값이 일정하게 증감할 때
우리는 for문을 씁니다.

하지만 for문의 기본 구조는
1) (변수) 초기화
2) (반복) 조건
3) (블록 실행 후) 실행하고 싶은 코드

라서 생각보다 더 자유롭고,
**초기화, 증감은 생략도 가능**합니다.
(이러면 while문처럼 되어버립니다.)
 