```js
function solution(s) {
    const charCnt = new Map();
    [...s].forEach((c)=>{charCnt.set(c, (charCnt.get(c) || 0 ) + 1)});
    return [...s].filter((c)=>charCnt.get(c) === 1).sort().join('');
}
```

Map은 딕셔너리처럼 key-value로 관리해서
각 문자가 몇 번 등장했는지 세는 역할을 할 수 있다.

한번만 등장한 문자를 filter로 걸러주면 완성.

시간복잡도 O(2n)
```
Array.filter() 함수는 시간 복잡도가 O(n)
Map 탐색은 O(1) //get, set
```

## 왜 `Map`이 빠를까?

- `Map`은 내부적으로 **해시 테이블(hash table)** 방식으로 구현되어 있어서, 키를 해시로 변환하여 저장하고 검색합니다.

#### JS 객체는..
- JavaScript의 일반 객체 `{}`도 키-값 구조지만:
    - 문자열과 심볼만 키로 사용 가능 (ES6 이전)
    - 프로토타입 체인 문제, 해시 성능 등으로 `Map`보다 느릴 수 있음

=> 해시 테이블을 쓰지만 상대적으로 느릴 수는 있음.

- `Map`은 어떤 **타입의 키든 사용 가능**하고, **삽입 순서도 유지**합니다.


다른 풀이
```js
function solution(s) {
return s.split('')
	.filter(e=>s.split('').filter(e2=>e===e2).length === 1)
	.sort()
	.join('')
}
```

각 문자를 다시 필터로 넣어서 한번만 나오는 지를 조건으로 넣어 만든 함수.
뭔가 멋있다. 시간 복잡도는 O(n^2)이라서 좋지는 않다.