```js
function solution(bin1, bin2) {
    return (parseInt(bin1, 2) + parseInt(bin2, 2)).toString(2);
}
```

이렇게만 하면 이진수를 다룬다고 할 수 없을 것 같아
이진수 덧셈 논리 회로와 같은 방식으로 구현.

이미 공간 복잡도, 시간 복잡도 모두 망했지만,
최소한의 효율을 위해 1 bit 값인 boolean 사용.

```js
function solution(bin1, bin2) {
    const length = Math.max(bin1.length, bin2.length);
    const _bin1 = [...bin1].reverse().map(v=>v==='0'? false : true);
    const _bin2 = [...bin2].reverse().map(v=>v==='0'? false : true);
    
    const result = [];
    let carry = false;
    for(let i=0; i<length; i++){
        let a = _bin1[i]??false;
        let b = _bin2[i]??false;
        let cur = XOR(XOR(a, b), carry); // (a ^ b) ^ carry
        carry = (XOR(a, b)&&carry)||(a&&b); // ((a ^ b) & carry)||(a & b)
        
        result.push(cur);
    }
    if(carry){result.push(true);}
    return result.reverse().map(v=>v? '1' : '0').join('');
}

function XOR( a, b){
    return !(a&&b) && (a||b);
}
```

![[Pasted image 20250827142535.png]]