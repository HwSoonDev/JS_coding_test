
![alt text](<Pasted image 20250917171844.png>)
합집합 공식
```
n( A ∪ B ∪ C ) 
=  n(A) + n(B) + n (C) - n(A ∩ B) - n(B ∩ C) - n(A ∩ C) + n(A ∩ B ∩ C)
```
하지만 이건 여기서 못씁니다;;

여기서 구해야 하는 것은 교집합의 합집합입니다.

( a ∩ b )  ∪ ( b ∩ c ) ∪ ( a ∩ c )
![alt text](<Pasted image 20250917174740.png>)

```
n(A ∩ B) + n(B ∩ C) + n(A ∩ C) - 2 * n(A ∩ B ∩ C)
```

```js
function solution(lines) {
    const os_1 = overlapSection(lines[0], lines[1]);
    const os_2 = overlapSection(lines[1], lines[2]);
    const os_3 = overlapSection(lines[0], lines[2]);
    const os_a = overlapSection(os_1, lines[2]);
    return sectionLength(os_1) + sectionLength(os_2) + sectionLength(os_3)
        - (2*sectionLength(os_a));
}

function overlapSection( sec1, sec2 ){
    const max_min = Math.max(sec1[0], sec2[0]);
    const min_max = Math.min(sec1[1], sec2[1]);
    // 더 큰 왼쪽 끝이 더 작은 오른쪽 끝보다 크면 겹치지 않는다.
    if(max_min > min_max)return [0, 0]; 
    return [max_min, min_max]; //겹치면 그 구간을 반환.
}

function sectionLength( sec ){
    return sec[1] - sec[0];
}
```


다른 풀이
```js
function solution(lines) {
    let line = new Array(200).fill(0);

    lines.forEach(([a, b]) => {
        for(; a < b; a++) line[a+100]++;
    });

    return line.reduce((a, c) =>  c > 1 ? a + 1 : a, 0)
}
```

200 크기의 배열을 만들어서 선분에 해당하는 부분을 채우고,
두번 이상 겹치면 길이에 추가하는 단순한 코드로 해결.
(정수 좌표로 주어지기 때문에 가능한 부분이네요. 배열 길이가 200... ㅡ ㅡ;;)